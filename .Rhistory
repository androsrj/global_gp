if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
length(props)
tail(outcomes.df)
library(mvtnorm)
library(stringr)
library(dplyr)
use.2024 <- TRUE
margins <- data.frame(
az = c(8.5, 10.1, 3.5, -0.4, 1.7),
ga = c(5.2, 8.0, 5.1, -0.3, 1.2),
mi = c(-16.8, -9.5, 0.3, -2.8, -1.8),
nv = c(-12.5, -6.6, -2.4, -2.4, 0.6),
nc = c(-0.3, 2.2, 3.6, 1.3, 1.3),
pa = c(-10.3, -5.2, 0.7, -1.2, 0.0),
wi = c(-13.9, -6.7, 0.7, -0.6, -1.1)
)
if (use.2024 == FALSE) {
margins <- margins[-5, ]
rownames(margins) <- seq(2008, 2020, by = 4)
} else {
rownames(margins) <- seq(2008, 2024, by = 4)
}
round(cor(margins), 2)
round(cov(margins), 2)
Sigma <- cov(margins)
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
sort(props)
states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
outcomes.df <- t(sapply(1:length(props), function(i) {
as.logical(str_extract_all(combos[i], "TRUE|FALSE")[[1]])
}))
dim(outcomes.df)
colnames(outcomes.df) <- states
outcomes.df[outcomes.df == TRUE] <- "Trump"
outcomes.df[outcomes.df == FALSE] <- "Harris"
outcomes.df <- as.data.frame(outcomes.df)
outcomes.df$Prob <- as.numeric(unname(props))
outcomes.df <- outcomes.df %>% arrange(Prob)
head(outcomes.df)
tail(outcomes.df)
evs <- c(11, 16, 15, 6, 16, 19, 10)
trump.start <- 219
harris.start <- 226
outcomes.df$Winner <- numeric(nrow(outcomes.df))
for (i in 1:nrow(outcomes.df)) {
trump.ev <- trump.start + sum(evs * (outcomes.df[i, 1:7] == "Trump"))
harris.ev <- harris.start + sum(evs * (outcomes.df[i, 1:7] == "Harris"))
if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
tail(df.outcomes)
tail(outcomes.df)
years <- c(2004, 2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 1, 1, 3)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(X, 2, weighted.mean, w = weights)
means <- apply(margins 2, weighted.mean, w = weights)
means <- apply(margins, 2, weighted.mean, w = weights)
means
X.centered <- sweep(margins, 2, means, "-")
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
X.centered
means
years <- c(2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 1, 1, 3)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(margins, 2, weighted.mean, w = weights)
X.centered <- sweep(margins, 2, means, "-")
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
X.centered
(t(X.centered) %*% (X.centered * weights))
(X.centered * weights)
t(X.centered)
(X.centered * weights)
class(X.centered * weights)
class(means)
class(X.centered)
View(X.centered)
X.centered <- as.matrix(sweep(margins, 2, means, "-"))
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
cov.weighted
library(mvtnorm)
library(stringr)
library(dplyr)
use.2024 <- TRUE
margins <- data.frame(
az = c(8.5, 10.1, 3.5, -0.4, 1.7),
ga = c(5.2, 8.0, 5.1, -0.3, 1.2),
mi = c(-16.8, -9.5, 0.3, -2.8, -1.8),
nv = c(-12.5, -6.6, -2.4, -2.4, 0.6),
nc = c(-0.3, 2.2, 3.6, 1.3, 1.3),
pa = c(-10.3, -5.2, 0.7, -1.2, 0.0),
wi = c(-13.9, -6.7, 0.7, -0.6, -1.1)
)
if (use.2024 == FALSE) {
margins <- margins[-5, ]
rownames(margins) <- seq(2008, 2020, by = 4)
} else {
rownames(margins) <- seq(2008, 2024, by = 4)
}
round(cor(margins), 2)
round(cov(margins), 2)
years <- c(2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 1, 1, 3)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(margins, 2, weighted.mean, w = weights)
X.centered <- as.matrix(sweep(margins, 2, means, "-"))
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
#Sigma <- cov(margins)
Sigma <- cov.weighted
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
sort(props)
states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
outcomes.df <- t(sapply(1:length(props), function(i) {
as.logical(str_extract_all(combos[i], "TRUE|FALSE")[[1]])
}))
dim(outcomes.df)
colnames(outcomes.df) <- states
outcomes.df[outcomes.df == TRUE] <- "Trump"
outcomes.df[outcomes.df == FALSE] <- "Harris"
outcomes.df <- as.data.frame(outcomes.df)
outcomes.df$Prob <- as.numeric(unname(props))
outcomes.df <- outcomes.df %>% arrange(Prob)
head(outcomes.df)
tail(outcomes.df)
evs <- c(11, 16, 15, 6, 16, 19, 10)
trump.start <- 219
harris.start <- 226
outcomes.df$Winner <- numeric(nrow(outcomes.df))
for (i in 1:nrow(outcomes.df)) {
trump.ev <- trump.start + sum(evs * (outcomes.df[i, 1:7] == "Trump"))
harris.ev <- harris.start + sum(evs * (outcomes.df[i, 1:7] == "Harris"))
if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
means
library(mvtnorm)
library(stringr)
library(dplyr)
use.2024 <- TRUE
margins <- data.frame(
az = c(8.5, 10.1, 3.5, -0.4, 1.7),
ga = c(5.2, 8.0, 5.1, -0.3, 1.2),
mi = c(-16.8, -9.5, 0.3, -2.8, -1.8),
nv = c(-12.5, -6.6, -2.4, -2.4, 0.6),
nc = c(-0.3, 2.2, 3.6, 1.3, 1.3),
pa = c(-10.3, -5.2, 0.7, -1.2, 0.0),
wi = c(-13.9, -6.7, 0.7, -0.6, -1.1)
)
if (use.2024 == FALSE) {
margins <- margins[-5, ]
rownames(margins) <- seq(2008, 2020, by = 4)
} else {
rownames(margins) <- seq(2008, 2024, by = 4)
}
round(cor(margins), 2)
round(cov(margins), 2)
years <- c(2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 1, 1, 3)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(margins, 2, weighted.mean, w = weights)
X.centered <- as.matrix(sweep(margins, 2, means, "-"))
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
#Sigma <- cov(margins)
Sigma <- cov.weighted
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = means, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
sort(props)
states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
outcomes.df <- t(sapply(1:length(props), function(i) {
as.logical(str_extract_all(combos[i], "TRUE|FALSE")[[1]])
}))
dim(outcomes.df)
colnames(outcomes.df) <- states
outcomes.df[outcomes.df == TRUE] <- "Trump"
outcomes.df[outcomes.df == FALSE] <- "Harris"
outcomes.df <- as.data.frame(outcomes.df)
outcomes.df$Prob <- as.numeric(unname(props))
outcomes.df <- outcomes.df %>% arrange(Prob)
head(outcomes.df)
tail(outcomes.df)
evs <- c(11, 16, 15, 6, 16, 19, 10)
trump.start <- 219
harris.start <- 226
outcomes.df$Winner <- numeric(nrow(outcomes.df))
for (i in 1:nrow(outcomes.df)) {
trump.ev <- trump.start + sum(evs * (outcomes.df[i, 1:7] == "Trump"))
harris.ev <- harris.start + sum(evs * (outcomes.df[i, 1:7] == "Harris"))
if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
tail(outcomes.df)
library(mvtnorm)
library(stringr)
library(dplyr)
use.2024 <- TRUE
margins <- data.frame(
az = c(8.5, 10.1, 3.5, -0.4, 1.7),
ga = c(5.2, 8.0, 5.1, -0.3, 1.2),
mi = c(-16.8, -9.5, 0.3, -2.8, -1.8),
nv = c(-12.5, -6.6, -2.4, -2.4, 0.6),
nc = c(-0.3, 2.2, 3.6, 1.3, 1.3),
pa = c(-10.3, -5.2, 0.7, -1.2, 0.0),
wi = c(-13.9, -6.7, 0.7, -0.6, -1.1)
)
if (use.2024 == FALSE) {
margins <- margins[-5, ]
rownames(margins) <- seq(2008, 2020, by = 4)
} else {
rownames(margins) <- seq(2008, 2024, by = 4)
}
round(cor(margins), 2)
round(cov(margins), 2)
years <- c(2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 1, 1, 3)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(margins, 2, weighted.mean, w = weights)
X.centered <- as.matrix(sweep(margins, 2, means, "-"))
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
#Sigma <- cov(margins)
Sigma <- cov.weighted
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
sort(props)
states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
outcomes.df <- t(sapply(1:length(props), function(i) {
as.logical(str_extract_all(combos[i], "TRUE|FALSE")[[1]])
}))
dim(outcomes.df)
colnames(outcomes.df) <- states
outcomes.df[outcomes.df == TRUE] <- "Trump"
outcomes.df[outcomes.df == FALSE] <- "Harris"
outcomes.df <- as.data.frame(outcomes.df)
outcomes.df$Prob <- as.numeric(unname(props))
outcomes.df <- outcomes.df %>% arrange(Prob)
head(outcomes.df)
tail(outcomes.df)
evs <- c(11, 16, 15, 6, 16, 19, 10)
trump.start <- 219
harris.start <- 226
outcomes.df$Winner <- numeric(nrow(outcomes.df))
for (i in 1:nrow(outcomes.df)) {
trump.ev <- trump.start + sum(evs * (outcomes.df[i, 1:7] == "Trump"))
harris.ev <- harris.start + sum(evs * (outcomes.df[i, 1:7] == "Harris"))
if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
tail(outcomes.df)
library(mvtnorm)
library(stringr)
library(dplyr)
use.2024 <- TRUE
margins <- data.frame(
az = c(8.5, 10.1, 3.5, -0.4, 1.7),
ga = c(5.2, 8.0, 5.1, -0.3, 1.2),
mi = c(-16.8, -9.5, 0.3, -2.8, -1.8),
nv = c(-12.5, -6.6, -2.4, -2.4, 0.6),
nc = c(-0.3, 2.2, 3.6, 1.3, 1.3),
pa = c(-10.3, -5.2, 0.7, -1.2, 0.0),
wi = c(-13.9, -6.7, 0.7, -0.6, -1.1)
)
if (use.2024 == FALSE) {
margins <- margins[-5, ]
rownames(margins) <- seq(2008, 2020, by = 4)
} else {
rownames(margins) <- seq(2008, 2024, by = 4)
}
round(cor(margins), 2)
round(cov(margins), 2)
years <- c(2008, 2012, 2016, 2020, 2024)
weights <- c(1, 1, 3, 5, 10)
weighted.mean <- function(x, w) sum(x * w) / sum(w)
means <- apply(margins, 2, weighted.mean, w = weights)
X.centered <- as.matrix(sweep(margins, 2, means, "-"))
cov.weighted <- (t(X.centered) %*% (X.centered * weights)) / sum(weights)
#Sigma <- cov(margins)
Sigma <- cov.weighted
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
sort(props)
states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
outcomes.df <- t(sapply(1:length(props), function(i) {
as.logical(str_extract_all(combos[i], "TRUE|FALSE")[[1]])
}))
dim(outcomes.df)
colnames(outcomes.df) <- states
outcomes.df[outcomes.df == TRUE] <- "Trump"
outcomes.df[outcomes.df == FALSE] <- "Harris"
outcomes.df <- as.data.frame(outcomes.df)
outcomes.df$Prob <- as.numeric(unname(props))
outcomes.df <- outcomes.df %>% arrange(Prob)
head(outcomes.df)
tail(outcomes.df)
evs <- c(11, 16, 15, 6, 16, 19, 10)
trump.start <- 219
harris.start <- 226
outcomes.df$Winner <- numeric(nrow(outcomes.df))
for (i in 1:nrow(outcomes.df)) {
trump.ev <- trump.start + sum(evs * (outcomes.df[i, 1:7] == "Trump"))
harris.ev <- harris.start + sum(evs * (outcomes.df[i, 1:7] == "Harris"))
if (trump.ev >= 270) {
outcomes.df$Winner[i] <- "Trump"
} else if (harris.ev >= 270) {
outcomes.df$Winner[i] <- "Harris"
} else {
outcomes.df$Winner[i] <- "Tie"
}
}
table(outcomes.df$Winner)
aggregate(data = outcomes.df, Prob ~ Winner, sum)
tail(outcomes.df)
# Shrink the covariance matrix towards the identity
cov.matrix <- cov(margins)
lambda <- 0.2
target <- matrix(0.3, 7, 7)
diag(target) <- 1
shrunk.cov <- lambda * target + (1 - lambda) * cov.matrix
shrunk.cov
cor.matrix <- cor(margins)
target <- matrix(0.3, 7, 7)
diag(target) <- 1
shrunk.cor <- lambda * target + (1 - lambda) * cor.matrix
shrunk.cor
round(cor(margins), 2)
lambda <- 0.5
cor.matrix <- cor(margins)
target <- matrix(0.5, 7, 7)
diag(target) <- 1
shrunk.cor <- lambda * target + (1 - lambda) * cor.matrix
shrunk.cor
Sigma <- cov(margins)
Sigma[Sigma < 0] <- 0.1
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
wins <- sim > 0
outcomes <- apply(wins, 1, paste0, collapse = "")
props <- table(outcomes) / nReps
combos <- names(props)
length(props)
Sigma <- cov(margins)
Sigma[Sigma < 0] <- 0
mu <- rep(0, 7)
nReps <- 1000000
sim <- rmvnorm(n = nReps, mean = mu, sigma = Sigma)
setwd("~/research/global_gp")
# SOURCES
#source("mcmc_functions/slosh_mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(fields)
library(ggplot2)
library(Matrix)
load("data/slosh/flood_data.RData")
mySeed <- 1234
which.Z <- c(1:5)
n <- 100
nTest <- 25
S <- 10
STest <- 10
set.seed(mySeed)
which.storms <- sample(4000, S + STest)
train.storms <- which.storms[1:S]
test.storms <- which.storms[(S+1):(S+STest)]
subsample <- coords$x < -74.82 & coords$x > -74.84 & coords$y < 39.07 & coords$y > 39.05
coords.subset <- coords[subsample, ]
out.subset <- out[ , subsample]
set.seed(mySeed)
which.points <- sample(nrow(coords.subset), n + nTest)
train.index <- which.points[1:n]
test.index <- which.points[(n+1):(n+nTest)]
X <- cbind(coords.subset$elev_meters[train.index],
coords.subset$dist.east[train.index])
Z <- inputs[train.storms, which.Z]
Y <- matrix(c(t(as.matrix(out.subset[train.storms, train.index]))), ncol = 1)
U <- coords.subset[train.index, 1:2]
D <- fields::rdist(U)
XTest <- cbind(coords.subset$elev_meters[test.index],
coords.subset$dist.east[test.index])
ZTest <- inputs[test.storms, which.Z]
YTest <- matrix(c(t(as.matrix(out.subset[test.storms, test.index]))), ncol = 1)
UTest <- coords.subset[test.index, 1:2]
DTest <- fields::rdist(UTest)
flood.train <- list(X=X, Z=Z, Y=Y, U=U, D=D)
flood.test <- list(X=XTest, Z=ZTest, Y=YTest, U=UTest, D=DTest)
save(flood.train, flood.test, file = "data/slosh/flood_subset.RData")
K <- 9
#q <- ncol(X) + ncol(Z) + 1
q <- ncol(X) + 1
propSD <- list(sigb2 = seq(0.4, 0.6, length = q),
thb = seq(0.3, 0.5, length = q),
sigma2 = seq(0.4, 0.6, length = K),
tau2 = 0.2,
theta = seq(0.5, 0.8, length = K))
starting <- list(sigma2 = seq(0.01, 0.1, length = K),
theta = rep(0.5, K),
sigb2 = rep(1, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0,7))
cat("Setup complete \n")
results <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 50, nBurn = 50, nThin = 2, nReport = 10,
model = "full_gp")
#theta
sd(YTest)
results$posteriorMeans
results$acceptance
nSamples <- length(results$paramSamples[[5]])
library(MBA)
library(fields)
STest <- nrow(ZTest)
rmse <- cvg <- width <- scores <- crps <- numeric(STest)
a <- .05
for (i in 1:STest) {
truth <- YTest[(nTest*(i-1)+1):(i*nTest)]
pred <- results$preds[2, (nTest*(i-1)+1):(i*nTest)]
rmse[i] <- sqrt(mean((truth - pred)^2))
lower <- pmax(0, results$preds[1, (nTest*(i-1)+1):(i*nTest)])
upper <- results$preds[3, (nTest*(i-1)+1):(i*nTest)]
cvg[i] <- mean(lower < truth & upper > truth)
width[i] <- mean(upper - lower)
scores[i] <- mean((upper - lower) +
2/a * (lower - truth) * (truth < lower) +
2/a * (truth - upper) * (truth > upper))
predSamples <- t(results$predSamples[(nTest*(i-1)+1):(i*nTest), ])
crps[i] <- mean(energy_score(truth, predSamples))
}
rmse
cat(paste0("Root MS error: ", round(mean(rmse), 3), "\n"))
cvg
cat(paste0("Mean coverage: ", round(mean(cvg), 3), "\n"))
mean(cvg[c(1,3,4,6,8,9,10)])
width
cat(paste0("Mean width: ", round(mean(width), 3), "\n"))
sd(YTest)
