tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
dmvnorm(as.vector(Y), sigma = Sigma, log = TRUE)
}
sigb2.vals <- seq(0.5, 5, by = 0.5)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
sigb2.vals <- seq(5, 50, by = 5)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
source("other_functions/bsplines_2_3D.R")
library(mvtnorm)
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
S <- nrow(Z)
n <- nrow(X)
A <<- rep(1, S) %x% cbind(matrix(1, nrow = n, ncol = 1), X)
beta.surf <- train$B
sigma2 <- seq(5, 10, length = K)
theta <- seq(0.1, 0.5, length = K)
tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
dmvnorm(as.vector(Y), sigma = Sigma, log = TRUE)
}
sigb2.vals <- seq(50, 500, by = 50)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
sigb2.vals <- seq(500, 5000, by = 500)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
apply(train$X, 2, mean)
dim(Sigma)
Sigma[1:3,1:3]
source("other_functions/bsplines_2_3D.R")
library(mvtnorm)
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
S <- nrow(Z)
n <- nrow(X)
A <<- rep(1, S) %x% cbind(matrix(1, nrow = n, ncol = 1), X)
beta.surf <- train$B
sigma2 <- seq(5, 10, length = K)
theta <- seq(0.1, 0.5, length = K)
tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
dmvnorm(as.vector(Y), rep(1, S) %x% rowSums(X0 * beta.surf), Sigma, log = TRUE)
#dmvnorm(as.vector(Y), sigma = Sigma, log = TRUE)
}
sigb2.vals <- seq(500, 5000, by = 500)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
source("other_functions/bsplines_2_3D.R")
library(mvtnorm)
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
S <- nrow(Z)
n <- nrow(X)
A <<- rep(1, S) %x% cbind(matrix(1, nrow = n, ncol = 1), X)
beta.surf <- train$B
sigma2 <- seq(5, 10, length = K)
theta <- seq(0.1, 0.5, length = K)
tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
dmvnorm(as.vector(Y), rep(1, S) %x% rowSums(X0 * beta.surf), Sigma, log = TRUE)
#dmvnorm(as.vector(Y), sigma = Sigma, log = TRUE)
}
sigb2.vals <- seq(0.5, 5, by = 0.500)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
source("other_functions/bsplines_2_3D.R")
library(mvtnorm)
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
S <- nrow(Z)
n <- nrow(X)
A <<- rep(1, S) %x% cbind(matrix(1, nrow = n, ncol = 1), X)
beta.surf <- train$B
sigma2 <- seq(5, 10, length = K)
theta <- seq(0.1, 0.5, length = K)
tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
#dmvnorm(as.vector(Y), rep(1, S) %x% rowSums(X0 * beta.surf), Sigma, log = TRUE)
dmvnorm(as.vector(Y), sigma = Sigma, log = TRUE)
}
sigb2.vals <- seq(5, 50, by = 5)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
mu <- mean(train$Y)
mu
source("other_functions/bsplines_2_3D.R")
library(mvtnorm)
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
S <- nrow(Z)
n <- nrow(X)
A <<- rep(1, S) %x% cbind(matrix(1, nrow = n, ncol = 1), X)
beta.surf <- train$B
sigma2 <- seq(5, 10, length = K)
theta <- seq(0.1, 0.5, length = K)
tau2 <- 0.2
#sigb2 <- c(0.5, .75, 1)
thb <- c(0.02, 0.06, 0.1)
sigma.lik <- function(sigb2) {
sigb2 <- c(sigb2 - .25, sigb2, sigb2 + 0.25)
#sigb2 <- c(0.5 * sigb2, sigb2, 2 * sigb2)
#thb <- c(thb - 0.05, thb, thb + 0.05)
#thb <- rep(thb, 3)
C <- lapply(1:K, function(k) {
sigma2[k] * exp(-theta[k] * D)
})
# Covariance - eta
BF <- Bsplines_2D(Z, df = c(sqrt(K), sqrt(K)))
S <- nrow(Z)
C.array <- simplify2array(C)  # array of dim n x n x K
C.array <- aperm(C.array, c(3, 1, 2))  # now K x n x n
W.list <- lapply(1:K, function(k) tcrossprod(BF[, k]))  # each S x S
W.array <- simplify2array(W.list)  # S x S x K
C.eta <- Reduce('+', lapply(1:K, function(k) kronecker(W.array[, , k], C.array[k, , ])))
# Covariance - beta
X0 <- cbind(rep(1, n), X)
q <- ncol(X0)
CB <- lapply(1:q, \(j) sigb2[j] * exp(-thb[j] * D))
CXB <- Reduce("+", lapply(1:q, \(j) matrix(X0[ , j], nrow = n, ncol = n) * CB[[j]] *
matrix(X0[ , j], nrow = n, ncol = n, byrow = T)))
#lon <- U[ , 1]
#lat <- U[ , 2]
#beta.surf <- cbind(
#  lon - lat,
#  lon + lat - 100,
#  2 * lon - lat - 50
#)
#B <- Reduce("cbind", lapply(1:q, \(j) t(rmvnorm(1, sigma = CB[[j]])))) + beta.surf
#XB <- rep(1, S) %x% rowSums(X0 * B)
# Covariance - final
Sigma <<- matrix(1, S, S) %x% CXB + C.eta + tau2 * diag(n * S)
#Sigma <- C.eta + tau2 * diag(n * S)
# Likelihood
#beta.expanded <- beta.surf[rep(1:nrow(beta.surf), each = S), ]
#dmvnorm(as.vector(Y), rep(1, S) %x% rowSums(X0 * beta.surf), Sigma, log = TRUE)
dmvnorm(as.vector(Y), rep(mu, 1000), Sigma, log = TRUE)
}
sigb2.vals <- seq(5, 50, by = 5)
lik <- sapply(sigb2.vals, sigma.lik)
plot(sigb2.vals, lik)
sigb2.vals[which.max(lik)]
#thb.vals <- seq(0.02, 0.3, by = 0.02)
#lik <- sapply(thb.vals, sigma.lik)
#plot(thb.vals, lik)
#thb.vals[which.max(lik)]
rep(1, S) %x% rowSums(X0 * beta.surf)
X0 <- cbind(rep(1, n), train$X)
rep(1, S) %x% rowSums(X0 * beta.surf)
(rep(1, S) %x% rowSums(X0 * beta.surf))[1:5]
var(rep(1, S) %x% rowSums(X0 * beta.surf))
var(train$Y)
obj
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(999)
##### SCENARIO 1 #####
scen <- 2
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(1.0, 1.5, length = K),
sigb2 = seq(0.3, 0.4, length = q),
thb = seq(0.4, 0.5, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 1.5)
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
obj$posteriorMeans$sigb2
obj$posteriorMeans$thb
obj$posteriorMeans$tau2
obj$acceptance
obj$posteriorMeans$tau2
obj$posteriorMeans$sigma2
obj$posteriorMeans$thb
obj$posteriorMeans$theta
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(999)
##### SCENARIO 1 #####
scen <- 2
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(1.0, 1.5, length = K),
sigb2 = seq(0.3, 0.4, length = q),
thb = seq(0.4, 0.5, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 1.5)
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
obj$posteriorMeans$sigb2
obj$posteriorMeans$thb
obj$posteriorMeans$tau2
obj$acceptance
obj$posteriorMeans$theta
obj$posteriorMeans$sigma2
