tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
apply(test$B, 2, sd)
apply(matrix(obj$posteriorMeans$beta.test, ncol=3), 2, sd)
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(9999)
##### SCENARIO 1 #####
scen <- 1
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(0.5, 0.7, length = K),
sigb2 = seq(0.4, 0.6, length = q),
thb = seq(2.5, 3, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
apply(test$B, 2, sd)
apply(matrix(obj$posteriorMeans$beta.test, ncol=3), 2, sd)
obj$sigb2
obj$posteriorMeans$sigb2
obj$posteriorMeans$thb
obj$posteriorMeans$tau2
obj$acceptance
1/75
1/50
1/150
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(9999)
##### SCENARIO 1 #####
scen <- 1
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(0.5, 0.7, length = K),
sigb2 = seq(0.4, 0.6, length = q),
thb = seq(2.5, 3, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
apply(test$B, 2, sd)
apply(matrix(obj$posteriorMeans$beta.test, ncol=3), 2, sd)
obj$posteriorMeans$sigb2
obj$posteriorMeans$tb
obj$posteriorMeans$thb
obj$acceptance
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(9999)
##### SCENARIO 1 #####
scen <- 1
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(0.5, 0.7, length = K),
sigb2 = seq(0.4, 0.6, length = q),
thb = seq(0.5, 1, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
apply(test$B, 2, sd)
apply(matrix(obj$posteriorMeans$beta.test, ncol=3), 2, sd)
obj$acceptance
obj$posteriorMeans$thb
obj$posteriorMeans$sigb2
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(9999)
##### SCENARIO 1 #####
scen <- 1
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(0.5, 0.7, length = K),
sigb2 = seq(0.4, 0.6, length = q),
thb = seq(0.05, 0.1, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
# SOURCES
source("mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
source("other_functions/bsplines_2_3D.R")
library(MBA)
library(splines)
library(fields)
library(parallel)
library(doParallel)
library(foreach)
library(Matrix)
set.seed(9999)
##### SCENARIO 1 #####
scen <- 1
dir <- paste0("data/small/scen", scen, "/")
train <- readRDS(paste0(dir, "train.RDS"))
test <- readRDS(paste0(dir, "test.RDS"))
n <- nrow(train$X)
nTest <- nrow(test$X)
X <- train$X; XTest <- test$X
Z <- train$Z; ZTest <- test$Z
Y <- train$Y; YTest <- test$Y
U <- train$U; UTest <- test$U
D <- train$D; DTest <- test$D
K <- 9
q <- ncol(X) + 1
propSD <- list(sigma2 = seq(0.2, 0.3, length = K),
theta = seq(0.5, 0.7, length = K),
sigb2 = seq(0.4, 0.6, length = q),
thb = seq(0.5, 1, length = q),
tau2 = 0.25)
starting <- list(sigma2 = rep(50, K),
theta = rep(.25, K),
sigb2 = rep(0.5, q),
thb = rep(0.2, q),
tau2 = 0.1,
beta = rep(0, n*q))
obj <- mcmc(X = X, Z = Z, Y = Y, D = D, K = K,
starting = starting,
propSD = propSD,
nIter = 100, nBurn = 50, nThin=2,
model = "full_gp")
sqrt(mean((test$Y - obj$preds[2,])^2))
mean(test$Y < obj$preds[3,] & test$Y > obj$preds[1,])
mean(obj$preds[3,] - obj$preds[1,])
head(test$B)
head(matrix(obj$posteriorMeans$beta.test, ncol=3))
apply(test$B, 2, sd)
apply(matrix(obj$posteriorMeans$beta.test, ncol=3), 2, sd)
obj$acceptance
obj$posteriorMeans$thb
obj$posteriorMeans$tau2
setwd("~/research/storm_surges/flood")
source("../other_functions/helper_functions.R")
sketching <- readRDS("results/flood_results_sketching.RDS")
nngp <- readRDS("results/flood_results_nngp.RDS")
bass <- readRDS("results/flood_results_bass.RDS")
#bart <- readRDS("results/flood_results_bart.RDS")
indexTest <- readRDS("results/test_points.RDS")
nTest <- length(indexTest)
test_subjects <- 6:10
nTestSubj <- length(test_subjects)
load("data/flood_data.RData")
n <- nrow(coords)
# Parameter estimates
sigma2 <- c(sketching$means['sigma2'],
sketching$lower[1],
sketching$upper[1])
tau2 <- c(sketching$means['tau2'],
sketching$lower[2],
sketching$upper[2])
beta <- c(sketching$means['beta7'],
sketching$lower[9],
sketching$upper[9])
sketchParams <- data.frame(sigma2, tau2, beta)
rownames(sketchParams) <- c("mean", "lower", "upper")
# Calculate all predictive diagnostics
length <- cvg <- score <- mspe <- pct <- matrix(0, nrow = length(test_subjects), ncol = 3)
for (i in 1:nTestSubj) {
# True values
trueTest <- out[test_subjects[i], indexTest]
# Sketching predictions for storm i
sketchPreds <- sketching$predictions[[i]][2, ]
sketchLower <- sketching$predictions[[i]][1, ]
sketchUpper <- sketching$predictions[[i]][3, ]
# BASS predictions for storm i
bassPreds <- bass$preds[i, ]
bassLower <- bass$lower[i, ]
bassUpper <- bass$upper[i, ]
# BART predictions for storm i
#bartPreds <- bart$preds[((i - 1) * nTest + 1):(i * nTest)]
#bartLower <- bart$lower[((i - 1) * nTest + 1):(i * nTest)]
#bartUpper <- bart$upper[((i - 1) * nTest + 1):(i * nTest)]
# Length
lengthSketch <- mean(sketchUpper - sketchLower)
lengthNNGP <- mean(nngp$upper - nngp$lower)
lengthBass <- mean(bassUpper - bassLower)
#lengthBart <- mean(bartUpper - bartLower)
length[i, ] <- c(lengthSketch, lengthNNGP, lengthBass)
# Coverage
cvgSketch <- mean(sketchUpper > trueTest & sketchLower < trueTest)
cvgNNGP <- mean(nngp$upper > trueTest & nngp$lower < trueTest)
cvgBass <- mean(bassUpper > trueTest & bassLower < trueTest)
#cvgBart <- mean(bartUpper > trueTest & bartLower < trueTest)
cvg[i, ] <- c(cvgSketch, cvgNNGP, cvgBass)
# MSPE
mspeSketch <- mean((sketchPreds - trueTest)^2)
mspeNNGP <- mean((nngp$preds - trueTest)^2)
mspeBass <- mean((bassPreds - trueTest)^2)
#mspeBart <- mean((bartPreds - trueTest)^2)
mspe[i, ] <- c(mspeSketch, mspeNNGP, mspeBass)
# Interval score
a <- 0.05
scoreSketch <- mean( (sketchUpper - sketchLower) +
2/a * (sketchLower - trueTest) *
(trueTest < sketchLower) +
2/a * (trueTest - sketchUpper) *
(trueTest > sketchUpper) )
scoreNNGP <- mean( (nngp$upper - nngp$lower) +
2/a * (nngp$lower - trueTest) *
(trueTest < nngp$lower) +
2/a * (trueTest - nngp$upper) *
(trueTest > nngp$upper) )
scoreBass <- mean( (bassUpper - bassLower) +
2/a * (bassLower - trueTest) *
(trueTest < bassLower) +
2/a * (trueTest - bassUpper) *
(trueTest > bassUpper) )
#scoreBart <- mean( (bartUpper - bartLower) +
#		   2/a * (bartLower - trueTest) *
#		   (trueTest < bartLower) +
#		   2/a * (trueTest - bartUpper) *
#		   (trueTest > bartUpper) )
score[i, ] <- c(scoreSketch, scoreNNGP, scoreBass)
# Over/under 4 feet
trueFeet <- trueTest * 3.28084
trueOver <- trueFeet >= 4.0
sketchFeet <- sketchPreds * 3.28084
sketchOver <- sketchFeet >= 4.0
sketchPct <- mean(trueOver == sketchOver)
nngpFeet <- nngp$preds * 3.28084
nngpOver <- nngpFeet >= 4.0
nngpPct <- mean(trueOver == nngpOver)
bassFeet <- bassPreds * 3.28084
bassOver <- bassFeet >= 4.0
bassPct <- mean(trueOver == bassOver)
#bartFeet <- bartPreds * 3.28084
#bartOver <- bartFeet >= 4.0
#bartPct <- mean(trueOver == bartOver)
pct[i, ] <- c(sketchPct, nngpPct, bassPct)
}
warnings()
mspe
mspeSketch
sketchPreds
trueTest
length(sketchPreds)
length(trueTest)
sketchPreds - trueTest
mean((sketchPreds - trueTest)^2)
class(trueTest)
# Calculate all predictive diagnostics
length <- cvg <- score <- mspe <- pct <- matrix(0, nrow = length(test_subjects), ncol = 3)
for (i in 1:nTestSubj) {
# True values
trueTest <- as.numeric(out[test_subjects[i], indexTest])
# Sketching predictions for storm i
sketchPreds <- sketching$predictions[[i]][2, ]
sketchLower <- sketching$predictions[[i]][1, ]
sketchUpper <- sketching$predictions[[i]][3, ]
# BASS predictions for storm i
bassPreds <- bass$preds[i, ]
bassLower <- bass$lower[i, ]
bassUpper <- bass$upper[i, ]
# BART predictions for storm i
#bartPreds <- bart$preds[((i - 1) * nTest + 1):(i * nTest)]
#bartLower <- bart$lower[((i - 1) * nTest + 1):(i * nTest)]
#bartUpper <- bart$upper[((i - 1) * nTest + 1):(i * nTest)]
# Length
lengthSketch <- mean(sketchUpper - sketchLower)
lengthNNGP <- mean(nngp$upper - nngp$lower)
lengthBass <- mean(bassUpper - bassLower)
#lengthBart <- mean(bartUpper - bartLower)
length[i, ] <- c(lengthSketch, lengthNNGP, lengthBass)
# Coverage
cvgSketch <- mean(sketchUpper > trueTest & sketchLower < trueTest)
cvgNNGP <- mean(nngp$upper > trueTest & nngp$lower < trueTest)
cvgBass <- mean(bassUpper > trueTest & bassLower < trueTest)
#cvgBart <- mean(bartUpper > trueTest & bartLower < trueTest)
cvg[i, ] <- c(cvgSketch, cvgNNGP, cvgBass)
# MSPE
mspeSketch <- mean((sketchPreds - trueTest)^2)
mspeNNGP <- mean((nngp$preds - trueTest)^2)
mspeBass <- mean((bassPreds - trueTest)^2)
#mspeBart <- mean((bartPreds - trueTest)^2)
mspe[i, ] <- c(mspeSketch, mspeNNGP, mspeBass)
# Interval score
a <- 0.05
scoreSketch <- mean( (sketchUpper - sketchLower) +
2/a * (sketchLower - trueTest) *
(trueTest < sketchLower) +
2/a * (trueTest - sketchUpper) *
(trueTest > sketchUpper) )
scoreNNGP <- mean( (nngp$upper - nngp$lower) +
2/a * (nngp$lower - trueTest) *
(trueTest < nngp$lower) +
2/a * (trueTest - nngp$upper) *
(trueTest > nngp$upper) )
scoreBass <- mean( (bassUpper - bassLower) +
2/a * (bassLower - trueTest) *
(trueTest < bassLower) +
2/a * (trueTest - bassUpper) *
(trueTest > bassUpper) )
#scoreBart <- mean( (bartUpper - bartLower) +
#		   2/a * (bartLower - trueTest) *
#		   (trueTest < bartLower) +
#		   2/a * (trueTest - bartUpper) *
#		   (trueTest > bartUpper) )
score[i, ] <- c(scoreSketch, scoreNNGP, scoreBass)
# Over/under 4 feet
trueFeet <- trueTest * 3.28084
trueOver <- trueFeet >= 4.0
sketchFeet <- sketchPreds * 3.28084
sketchOver <- sketchFeet >= 4.0
sketchPct <- mean(trueOver == sketchOver)
nngpFeet <- nngp$preds * 3.28084
nngpOver <- nngpFeet >= 4.0
nngpPct <- mean(trueOver == nngpOver)
bassFeet <- bassPreds * 3.28084
bassOver <- bassFeet >= 4.0
bassPct <- mean(trueOver == bassOver)
#bartFeet <- bartPreds * 3.28084
#bartOver <- bartFeet >= 4.0
#bartPct <- mean(trueOver == bartOver)
pct[i, ] <- c(sketchPct, nngpPct, bassPct)
}
sketchCRPS <- mean(sapply(1:nTestSubj, function(i) {
truth <- out[test_subjects[i], indexTest]
preds <- sapply(1:nTestSubj, \(i) sketching$predictions[[i]][2, ])
mean(energy_score(truth, preds))
}))
length <- apply(length, 2, mean)
cvg <- apply(cvg, 2, mean)
mspe <- apply(mspe, 2, mean)
crps <- c(sketchCRPS, nngp$crps, bass$crps)
score <- apply(score, 2, mean)
pct <- 1 - apply(pct, 2, mean)
# Parameter estimates
sketchParams
nngp$params
# Predictive diagnostics
preds_df <- data.frame(mspe = mspe,
crps = crps,
cvg = cvg,
score = score,
pct = pct)
rownames(preds_df) <- c("Sketching", "NNGP", "BASS")
preds_df
# Also make sure that acceptance rates are satisfactory
sketching$acc
sketchCRPS <- mean(sapply(1:nTestSubj, function(i) {
truth <- out[test_subjects[i], indexTest]
preds <- sapply(1:nTestSubj, \(i) sketching$predictions[[i]][2, ])
mean(energy_score(truth, preds))
}))
crps <- c(sketchCRPS, nngp$crps, bass$crps)
crps
sketchCRPS <- mean(sapply(1:nTestSubj, function(i) {
truth <- as.numeric(out[test_subjects[i], indexTest])
preds <- sapply(1:nTestSubj, \(i) sketching$predictions[[i]][2, ])
mean(energy_score(truth, preds))
}))
sketchCRPS
setwd("~/research/global_gp")
