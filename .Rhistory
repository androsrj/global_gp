tree_contradict <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df_contradict, method = "class")
rpart.plot(tree_contradict, main = "Tree 2: After Adding Contradictory Observations")
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 45
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
View(df)
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 45
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
set.seed(123)  # for reproducibility
# Simulate data
n <- 45
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Simulate data
n <- 25
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
?rpart
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 25
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 25
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
#rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 25
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
#rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
library(rpart)
library(rpart.plot)
set.seed(123)  # for reproducibility
# Simulate data
n <- 25
Age <- sample(25:60, n, replace = TRUE)
Income <- sample(40:150, n, replace = TRUE)
EducationLevel <- sample(c("HighSchool", "College", "Graduate"), n, replace = TRUE)
#BoughtHouse <- ifelse(Age > 35 & Income > 70, "Yes", "No")  # underlying rule
BoughtHouse <- sample(c("Yes", "No"), n, replace = TRUE)
# Add noise
BoughtHouse[sample(1:n, 5)] <- sample(c("Yes", "No"), 5, replace = TRUE)
# Create data frame
df <- data.frame(Age, Income, EducationLevel = as.factor(EducationLevel), BoughtHouse = as.factor(BoughtHouse))
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Add a person who "should" have bought a house, but didn't
new_obs <- data.frame(Age = 50, Income = 120, EducationLevel = "Graduate", BoughtHouse = "No")
df2 <- rbind(df, new_obs)
tree2 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df2, method = "class")
#rpart.plot(tree2, main = "Tree 2: After Adding One Contradictory Point")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 5))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 3))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 2))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 1))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 10))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 20))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(BoughtHouse ~ Age + Income + EducationLevel, data = df, method = "class",
control = rpart.control(minsplit = 10))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
# Create the dataset
df <- data.frame(
Weather = c("Rain", "Sunny", "Sunny", "Rain", "Sunny",
"Cloudy", "Sunny", "Sunny", "Rain", "Cloudy",
"Sunny", "Rain"),
Temperature = c(65, 78, 82, 71, 89,
58, 73, 76, 56, 64,
81, 67),
Wind = c("High", "Medium", "Low", "Medium", "Low",
"Low", "Low", "Low", "High", "Medium",
"Medium", "Low"),
WalkDog = c("No", "Yes", "Yes", "No", "Yes",
"No", "Yes", "Yes", "No", "Yes",
"Yes", "No")
)
tree1 <- rpart(WalkDog ~ Weather + Temperature + Wind, data = df, method = "class")
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1$frame
7/12
tree1 <- rpart(WalkDog ~ Weather + Temperature + Wind, data = df, method = "class",
control = rpart.control(minSplit = 1))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(WalkDog ~ Weather + Temperature + Wind, data = df, method = "class",
control = rpart.control(minsplit = 1))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(WalkDog ~ Weather + Temperature + Wind, data = df, method = "class",
control = rpart.control(minsplit = 2))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
tree1 <- rpart(WalkDog ~ Weather + Temperature + Wind, data = df, method = "class",
control = rpart.control(minsplit = 3))
rpart.plot(tree1, main = "Tree 1: Original Dataset")
pnorm(30, 23, 3) - pnorm(24, 23, 3)
setwd("~/research/spatcat")
library(dplyr)
# Read in data
nash <- readRDS("results/nashville/nashville_conditional_chain1.RDS")
index <- readRDS("results/indices/nashville_conditional_indices.RDS")
dat <- readRDS("datasets/nashville_subset.RDS")
coords <- readRDS("datasets/coords.RDS")
# Filter data to where area and roof material are present
dat <- dat[!is.na(dat$area) & !is.na(dat$roof_mat), ]
getMode <- function(var) {
as.numeric(names(which.max(table(var))))
}
preds <- apply(nash$XDraws, c(1,2), getMode)
H <- 3
# Proportions of predicted classes in test data
prop.table(table(preds[index$areaMissing, 1]))
prop.table(table(preds[index$roofMissing, 2]))
# Proportions of actual classes in full (not missing) data
prop.table(table(dat$area))
prop.table(table(dat$roof_mat))
# Proportions of actual classes in test data
prop.table(table(dat$area[index$areaMissing]))
prop.table(table(dat$roof_mat[index$roofMissing]))
# Explore probabilities (psi) for area variable
dim(nash$psi[[1]])
area.probs <- apply(nash$psi[[1]], 1:2, mean)
area.probs
# Check latent classes Z (should be same for every iteration)
dim(nash$Z)
table(nash$Z[1,])
dim(dat)
head(dat)
table(dat$area[dat$purpose=="res"])
table(dat$area[dat$purpose=="com"])
prior.data <- read.csv("datasets/expert_elicitation.csv")[,-1]
# Priors for area
prior.area <- prior.data %>% filter(child_var == "area")
com.area <- c(min.prob, prior.area$probability[7:10]) # for purpose = commercial
res.area <- c(min.prob, prior.area$probability[4:6], min.prob) # for purpose = residential
# Read in prior elicitations
min.prob <- 1e-5
prior.data <- read.csv("datasets/expert_elicitation.csv")[,-1]
# Priors for area
prior.area <- prior.data %>% filter(child_var == "area")
com.area <- c(min.prob, prior.area$probability[7:10]) # for purpose = commercial
res.area <- c(min.prob, prior.area$probability[4:6], min.prob) # for purpose = residential
com.area
# Priors for area
prior.area <- prior.data %>% filter(child_var == "area")
View(prior.area)
res.area
# Priors for roof material
prior.roof <- prior.data %>% filter(child_var == "roof_mat")
table(dat$roof_mat[dat$purpose=="com"])
table(dat$roof_mat[dat$purpose=="res"])
View(prior.roof)
com.roof <- prior.roof$probability[6:11] # for purpose = commercial
com.roof <- c(com.roof[1]/2, min.prob, com.roof[3], com.roof[1]/2, com.roof[4:6])
res.roof <- prior.roof$probability[2:5] # for purpose = residential
res.roof <- c(res.roof[1], min.prob, min.prob, res.roof[2:4], min.prob)
res.roof
# Explore probabilities (psi) for area variable
dim(nash$psi[[1]])
area.probs <- apply(nash$psi[[1]], 1:2, mean)
area.probs
table(nash$Z[1,])
res.area
dim(Nash$psi[[1]])
dim(nash$psi[[1]])
apply(nash$psi[[1]][,,1:2500], 1:2, mean)
apply(nash$psi[[1]][,,2501:5000], 1:2, mean)
apply(nash$psi[[1]][,,1:100], 1:2, mean)
nash$psi[[1]][,,1]
plot(nash$psi[[1]][3,3,], type='l')
plot(nash$psi[[1]][3,3,], type='l', ylim = c(0.2, 0.5))
lines(1:5000, nash$psi[[1]][2,3,])
sum(nash$psi[[1]][3,3,] > nash$psi[[1]][2,3,])
mean(nash$psi[[1]][3,3,] - nash$psi[[1]][2,3,])
prop.table(table(dat$area[index$areaMissing]))
area.test <- dat$area[index$areaMissing]
purpose.test <- dat$purpose[index$areaMissing]
table(purpose.test)
length(index$areaMissing)
dim(nash$Z)
table(nash$Z[1, index$areaMissing])
table(dat$area[index$areaMissing])
prop.table(table(dat$area[index$areaMissing]))
sum(prop.table(table(dat$area[index$areaMissing]))^2)
.45^2
index <- readRDS("results/indices/nashville_conditional_indices.RDS")
length(index$areaMissing)
# Read in data
nash <- readRDS("results/nashville/nashville_conditional_chain1.RDS")
index <- readRDS("results/indices/nashville_conditional_indices.RDS")
dat <- readRDS("datasets/nashville_subset.RDS")
coords <- readRDS("datasets/coords.RDS")
# Filter data to where area and roof material are present
dat <- dat[!is.na(dat$area) & !is.na(dat$roof_mat), ]
getMode <- function(var) {
as.numeric(names(which.max(table(var))))
}
preds <- apply(nash$XDraws, c(1,2), getMode)
H <- 3
# Proportions of predicted classes in test data
prop.table(table(preds[index$areaMissing, 1]))
prop.table(table(preds[index$roofMissing, 2]))
# Proportions of actual classes in full (not missing) data
prop.table(table(dat$area))
prop.table(table(dat$roof_mat))
# Proportions of actual classes in test data
prop.table(table(dat$area[index$areaMissing]))
prop.table(table(dat$roof_mat[index$roofMissing]))
# Explore probabilities (psi) for area variable
dim(nash$psi[[1]])
area.probs <- apply(nash$psi[[1]], 1:2, mean)
area.probs
gc()
table(nash$Z[1, index$areaMissing])
# Actual distribution of area among test data
prop.table(table(dat$area[index$areaMissing]))
# Actual distribution of purpose among test data
prop.table(table(dat$purpose[index$areaMissing]))
table(dat$purpose[index$areaMissing])
table(dat$area[index$areaMissing])
# Read in data
nash <- readRDS("results/nashville/nashville_conditional_chain1.RDS")
index <- readRDS("results/indices/nashville_conditional_indices.RDS")
getMode <- function(var) {
as.numeric(names(which.max(table(var))))
}
preds <- apply(nash$XDraws, c(1,2), getMode)
H <- 3
# Proportions of predicted classes in test data
prop.table(table(preds[index$areaMissing, 1]))
prop.table(table(preds[index$roofMissing, 2]))
# Proportions of actual classes in full (not missing) data
prop.table(table(dat$area))
prop.table(table(dat$roof_mat))
# Proportions of actual classes in test data
prop.table(table(dat$area[index$areaMissing]))
prop.table(table(dat$roof_mat[index$roofMissing]))
# Explore probabilities (psi) for area variable
dim(nash$psi[[1]])
area.probs <- apply(nash$psi[[1]], 1:2, mean)
area.probs
setwd("~/research/global_gp")
library(spBayes)
source("other_functions/helper_functions.R")
run.svc <- function(scen, nReps) {
d.max <- max(iDist(train$U))
r <- 2
n <<- nrow(train$X)
nTest <- nrow(test$X)
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 5000
results <- vector("list", nReps)
for (i in 1:nReps) {
m.3 <- spSVC(train$Y[1:n,] ~ train$X, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
results[[i]] <- m.3
}
saveRDS(results, paste0("objects/svc_scen", scen, ".RDS"))
return(paste0("Completed Scenario ", scen))
}
nReps=3
# Scenario 1
load("data/small/scen1/train.RData")
# Scenario 1
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
run.svc(1, nReps)
library(spBayes)
source("other_functions/helper_functions.R")
run.svc <- function(scen, nReps) {
d.max <- max(iDist(train$U))
r <- 2
n <<- nrow(train$X)
nTest <- nrow(test$X)
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 5000
results <- vector("list", nReps)
for (i in 1:nReps) {
m.3 <- spSVC(train$Y[1:n,] ~ train$X, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
results[[i]] <- m.3
}
saveRDS(results, paste0("objects/svc_scen", scen, ".RDS"))
return(paste0("Completed Scenario ", scen))
}
nReps <- 10
# Scenario 1
train <- readRDS("data/small/scen1/train.RDS")
test <- readRDS("data/small/scen1/test.RDS")
run.svc(1, nReps)
train$X
nrow(train$X)
scen=1
d.max <- max(iDist(train$U))
r <- 2
n <<- nrow(train$X)
n <- nrow(train$X)
run.svc <- function(scen, nReps) {
d.max <- max(iDist(train$U))
r <- 2
n <- nrow(train$X)
nTest <- nrow(test$X)
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 5000
results <- vector("list", nReps)
for (i in 1:nReps) {
m.3 <- spSVC(train$Y[1:n,] ~ train$X, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
results[[i]] <- m.3
}
saveRDS(results, paste0("objects/svc_scen", scen, ".RDS"))
return(paste0("Completed Scenario ", scen))
}
nReps <- 10
nReps=3
run.svc(1, nReps)
temp <- run.svc(1, nReps)
scen1 <- readRDS("objects/svc_scen1.RDS")
length(scen1)
x <- scen1
rm(scen1)
dim(x[[1]]$p.beta.recover.samples)
nrow(train$X)
scen1 <- readRDS("objects/svc_scen1.RDS")
x <- scen1[[1]]
dim(x$X)
dim(x$p.y.samples)
dim(x$p.theta.samples)
dim(x$p.theta.recover.samples)
scen
d.max <- max(iDist(train$U))
r <- 2
n <- nrow(train$X)
nTest <- nrow(test$X)
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 5000
m.3 <- spSVC(train$Y[1:n,] ~ train$X, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
dim(m.3$p.theta.samples)
head(m.3$p.theta.samples)
dim(x$p.theta.samples)
dim(x$p.w.recover.samples)
dim(x$p.w.recover.samples.list)
class(x$p.w.recover.samples.list)
length(x$p.w.recover.samples.list)
dim(x$p.w.recover.samples.list[[1]])
dim(x$p.w.recover.samples.list[[2]])
dim(x$p.beta.recover.samples)
dim(x$p.tilde.beta.recover.samples.list)
length(x$p.tilde.beta.recover.samples.list)
dim(x$p.theta.recover.samples[[1]])
class(x$p.theta.recover.samples[[1]])
class(x$p.tilde.beta.recover.samples.list[[1]])
dim(x$p.tilde.beta.recover.samples.list[[1]])
btilde <- apply(x$p.tilde.beta.recover.samples.list[[1]], 1, mean)
btilde
mean(btilde)
mean(x$p.beta.recover.samples)
dim(x$p.beta.recover.samples)
apply(x$p.beta.recover.samples, 2, mean)
length(x$p.tilde.beta.recover.samples.list)
btilde <- apply(x$p.tilde.beta.recover.samples.list[[2]], 1, mean)
mean(btilde)
dim(x$p.tilde.beta.recover.samples.list[[1]])
dim(x$p.tilde.beta.recover.samples.list[[2]])
