summary(test$X[,2])
m.3.pred <- spPredict(m.3, pred.covars=cbind(1, rnorm(2336, 0, 1.7)),
pred.coords=PM10.pred[,1:2], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=cbind(1, rnorm(50, 4.6, 1.2)),
pred.coords=test$U, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
duplicated(test$U)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=PM10.pred[1:50,1:2], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
test$U
head(PM10.pred)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U * 10 + rnorm(100), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U * 10, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U , thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
source("other_functions/spatial_data.R")
source("other_functions/bsplines_2_3D.R")
mySeed <- 3215877
# Sample sizes
n <-200
nTest <- 50
S <- 10
STest <- 10
K <- 9
# True parameter values
trueSigma2 <- seq(50, 100, length = K)
trueTau2 <- 0.2
trueTheta <- runif(K, 0.01, 0.1)
trueBeta <- c(3, -2)
# Generate training data
#set.seed(mySeed)
X <- cbind(matrix(1, nrow = n),
runif(n, -5, 5))
Z <- matrix(runif(2 * S, 0, 100), ncol = 2)
train <- spatialData(n = n,
X = X,
Z = Z,
K = K,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 100))
save(train, file = "data/train.RData")
set.seed(mySeed)
indexTest <- sample(n, nTest)
U <- train$U[indexTest, ]
# Generate testing data
#set.seed(mySeed)
XTest <- cbind(matrix(1, nrow = nTest),
runif(nTest, -5, 5))
ZTest <- matrix(runif(2 * STest, 0, 100), ncol = 2)
test <- spatialData(n = nTest,
X = XTest,
Z = ZTest,
K = K,
U = U,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 100))
test$index <- indexTest
save(test, file = "data/test.RData")
save(trueTheta, file = "data/theta.RData")
trueSigma2
trueTheta
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y[1:200,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.75*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*10, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
test$U
m.3.pred <- spPredict(m.3, pred.covars=test$X[1:10,],
pred.coords=test$U[1:10,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[11:20,],
pred.coords=test$U[11:20,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
test$U
m.3.pred <- spPredict(m.3, pred.covars=test$X[1:3,],
pred.coords=test$U[1:3,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[1:2,],
pred.coords=test$U[1:2,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[1,],
pred.coords=test$U[1,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[49:50,],
pred.coords=test$U[49:50,], thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[49:50,],
pred.coords=test$U[49:50,]*10, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
test$U[49:50,]*10
source("other_functions/spatial_data.R")
source("other_functions/bsplines_2_3D.R")
mySeed <- 3215877
# Sample sizes
n <-200
nTest <- 50
S <- 10
STest <- 10
K <- 9
# True parameter values
trueSigma2 <- seq(50, 100, length = K)
trueTau2 <- 0.2
trueTheta <- runif(K, 0.01, 0.1)
trueBeta <- c(3, -2)
# Generate training data
#set.seed(mySeed)
X <- cbind(matrix(1, nrow = n),
runif(n, -5, 5))
Z <- matrix(runif(2 * S, 0, 100), ncol = 2)
train <- spatialData(n = n,
X = X,
Z = Z,
K = K,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 1000))
save(train, file = "data/train.RData")
set.seed(mySeed)
indexTest <- sample(n, nTest)
U <- train$U[indexTest, ]
# Generate testing data
#set.seed(mySeed)
XTest <- cbind(matrix(1, nrow = nTest),
runif(nTest, -5, 5))
ZTest <- matrix(runif(2 * STest, 0, 100), ncol = 2)
test <- spatialData(n = nTest,
X = XTest,
Z = ZTest,
K = K,
U = U,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 1000))
test$index <- indexTest
save(test, file = "data/test.RData")
save(trueTheta, file = "data/theta.RData")
trueSigma2
trueTheta
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y[1:200,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.75*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X[49:50,],
pred.coords=test$U[49:50,]*10, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*10, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*5, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*2, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*1, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*1.5, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*1.1, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*1.01, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U*1.0001, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
test$U*1.0001
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.01), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred$p.y.predictive.samples
dim(m.3.pred$p.y.predictive.samples)
?spPredict
.75*500
m.3 <- spSVC(train$Y[1:200,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.01), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
dim(m.3.pred$p.y.predictive.samples)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U, thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
rnorm(50, 0, 0.0001)
source("other_functions/spatial_data.R")
source("other_functions/bsplines_2_3D.R")
mySeed <- 3215877
# Sample sizes
n <-200
nTest <- 50
S <- 10
STest <- 10
K <- 9
# True parameter values
trueSigma2 <- seq(50, 100, length = K)
trueTau2 <- 0.2
trueTheta <- runif(K, 0.01, 0.1)
trueBeta <- c(3, -2)
# Generate training data
#set.seed(mySeed)
X <- cbind(matrix(1, nrow = n),
runif(n, -5, 5))
Z <- matrix(runif(2 * S, 0, 100), ncol = 2)
train <- spatialData(n = n,
X = X,
Z = Z,
K = K,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 100))
save(train, file = "data/train.RData")
set.seed(mySeed)
indexTest <- sample(n, nTest)
U <- train$U[indexTest, ]
# Generate testing data
#set.seed(mySeed)
XTest <- cbind(matrix(1, nrow = nTest),
runif(nTest, -5, 5))
ZTest <- matrix(runif(2 * STest, 0, 100), ncol = 2)
test <- spatialData(n = nTest,
X = XTest,
Z = ZTest,
K = K,
U = U,
sigma2 = trueSigma2,
tau2 = trueTau2,
theta = trueTheta,
beta = trueBeta,
range = c(0, 100))
test$index <- indexTest
save(test, file = "data/test.RData")
save(trueTheta, file = "data/theta.RData")
trueSigma2
trueTheta
library(spBayes)
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y[1:200,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
dim(m.3.pred$p.y.predictive.samples)
y.pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
y.pred
sqrt(mean((test$Y[1:50,] - y.pred)^2))
sd(test$Y[1:50,])
setwd("~/research/global_gp")
library(spBayes)
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y[1:200,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=25,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
y.pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
sqrt(mean((test$Y[1:50,] - y.pred)^2))
sd(test$Y[1:50,])
m <- matrix(1:4, 2, 2)
m
rep(m, 2)
dim(matrix(rep(train$X, 10), 2000))
m.3 <- spSVC(train$Y ~ matrix(rep(train$X, 10), 2000) - 1,
coords = matrix(rep(train$U, 10), 2000),
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spSVC(train$Y ~ matrix(rep(train$X, 10), 2000) - 1,
coords = matrix(rep(train$U, 10), 2000) + rnorm(4000, 0, 0.01),
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
library(spBayes)
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
library(spBayes)
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
library(spBayes)
load("data/train.RData")
load("data/test.RData")
load("data/theta.RData")
d.max <- max(iDist(train$U))
r <- 2
n <- nrow(train$X)
nTest <- nrow(test$X)
priors <- list("phi.Unif"=list(rep(3/(0.75*d.max), r), rep(3/(0.001*d.max), r)),
"sigma.sq.IG"=list(rep(2, r), rep(1, r)),
"tau.sq.IG"=c(2, 1))
starting <- list("phi"=rep(3/(0.1*d.max), r), "sigma.sq"=rep(1, r), "tau.sq"=1)
tuning <- list("phi"=rep(0.1, r), "sigma.sq"=rep(0.05, r), "tau.sq"=0.1)
n.samples <- 500
m.3 <- spSVC(train$Y[1:nTest,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spSVC(train$Y[1:n,] ~ train$X - 1, coords=train$U,
starting=starting, svc.cols=c(1,2),
tuning=tuning, priors=priors, cov.model="exponential",
n.samples=n.samples, n.report=5000, n.omp.threads=4)
m.3 <- spRecover(m.3, start=floor(0.5*n.samples), thin=2,
n.omp.threads=4, verbose=FALSE)
STest <- nrow(test$Z)
abs_error <- cvg <- width <- scores <- crps <- numeric(STest)
a <- .05
for (i in 1:STest) {
truth <- test$Y[(nTest*(i-1)+1):(nTest*i), ]
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=10,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
abs_error[i] <- mean(abs(truth - pred))
lower <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .025)
upper <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .975)
cvg[i] <- mean(lower < truth & upper > truth)
width[i] <- mean(upper - lower)
scores[i] <- mean((upper - lower) +
2/a * (lower - truth) * (truth < lower) +
2/a * (truth - upper) * (truth > upper))
predSamples <- t(results$predSamples[(nTest*(i-1)+1):(i*nTest), ])
crps[i] <- mean(energy_score(truth, predSamples))
}
dim(m.3.pred)
dim(m.3.pred$p.y.predictive.samples)
for (i in 1:STest) {
truth <- test$Y[(nTest*(i-1)+1):(nTest*i), ]
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=10,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
abs_error[i] <- mean(abs(truth - pred))
lower <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .025)
upper <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .975)
cvg[i] <- mean(lower < truth & upper > truth)
width[i] <- mean(upper - lower)
scores[i] <- mean((upper - lower) +
2/a * (lower - truth) * (truth < lower) +
2/a * (truth - upper) * (truth > upper))
predSamples <- m.3.pred$p.y.predictive.samples
crps[i] <- mean(energy_score(truth, predSamples))
}
source("other_functions/helper_functions.R")
for (i in 1:STest) {
truth <- test$Y[(nTest*(i-1)+1):(nTest*i), ]
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=10,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
abs_error[i] <- mean(abs(truth - pred))
lower <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .025)
upper <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .975)
cvg[i] <- mean(lower < truth & upper > truth)
width[i] <- mean(upper - lower)
scores[i] <- mean((upper - lower) +
2/a * (lower - truth) * (truth < lower) +
2/a * (truth - upper) * (truth > upper))
predSamples <- m.3.pred$p.y.predictive.samples
crps[i] <- mean(energy_score(truth, predSamples))
}
abs_error
cat(paste0("Mean absolute error: ", round(mean(abs_error), 3), "\n"))
cvg
cat(paste0("Mean coverage: ", round(mean(cvg), 3), "\n"))
width
cat(paste0("Mean width: ", round(mean(width), 3), "\n"))
scores
cat(paste0("Mean interval score: ", round(mean(scores), 3), "\n"))
crps
cat(paste0("Mean CRPS: ", round(mean(crps), 3), "\n"))
for (i in 1:STest) {
truth <- test$Y[(nTest*(i-1)+1):(nTest*i), ]
m.3.pred <- spPredict(m.3, pred.covars=test$X,
pred.coords=test$U + rnorm(50, 0, 0.0001), thin=10,
joint=TRUE, n.omp.threads=4, verbose=FALSE)
pred <- apply(m.3.pred$p.y.predictive.samples, 1, mean)
abs_error[i] <- mean(abs(truth - pred))
lower <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .025)
upper <- apply(m.3.pred$p.y.predictive.samples, 1, quantile, .975)
cvg[i] <- mean(lower < truth & upper > truth)
width[i] <- mean(upper - lower)
scores[i] <- mean((upper - lower) +
2/a * (lower - truth) * (truth < lower) +
2/a * (truth - upper) * (truth > upper))
predSamples <- t(m.3.pred$p.y.predictive.samples)
crps[i] <- mean(energy_score(truth, predSamples))
}
abs_error
cat(paste0("Mean absolute error: ", round(mean(abs_error), 3), "\n"))
cvg
cat(paste0("Mean coverage: ", round(mean(cvg), 3), "\n"))
width
cat(paste0("Mean width: ", round(mean(width), 3), "\n"))
scores
cat(paste0("Mean interval score: ", round(mean(scores), 3), "\n"))
crps
cat(paste0("Mean CRPS: ", round(mean(crps), 3), "\n"))
